## C++ - explicit

C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 

而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的, 类构造函数默认情况下即声明为implicit(隐式).

显示声明的构造函数和隐式声明的有什么区别呢?

```c++
#include <iostream>
using namespace std;
class A {
  public:
    A(int i = 5) {
        m_a = i;
      }
    A(char *p) {
    }
  private:
    int m_a;
};
int main() {
  A(10);              //这是可以的
  A  s = 10;          //可以的，m_a被改成了10
  " A  s = 10;" 这句为什么是可以的呢?
  在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:
  将该构造函数对应数据类型的数据转换为该类对象. 
  也就是说 "A  s = 10;" 这段代码, 编译器自动将整型转换为A类对象, 实际上等同于下面的操作:
  A s(10);  
或  
  A temp(10);  
  A s = temp;  
  为什么赋值语句会隐式调用构造函数：
  类A有自定义构造函数，所以编译器不会自动生成编译器，
  但会自动生成析构函数，复制构造函数，赋值函数，取址函数。
  s = 10； 执行顺序如下：
  "10"隐式转换为实例A，即调用A(int)构造生成临时实例t，变为A a = t;
  临时实例t隐式调用复制构造函数，把t复制给a，t销毁。

  A s;           // 这样是不行，因为没有默认的构造函数
  A s("hello");  // 可以
  A s = "hello"; // 可以
  A s = 'c';     // 可以，其实调用的是A(int size), 且size等于'c'的ascii码  
  这句容易让人疑惑. 有什么办法阻止这种用法呢?
  那就是使用使用explicit关键字，explicit关键字的作用就是防止类构造函数的隐式自动转换.
  return 0;
}

修改后的版本：
explicit A(int i = 5) {
  m_a = i;
}

A(10);             // 这是可以的
A  s = 10;         // 不可以的，因为explicit关键字取消了隐式转换 
A s;               // 样是不行，因为没有默认的构造函数
A s("hello");      // 可以的
A s = "hello";     // 可以的
A s = 'c';         // 不可以的

⚠️注意的地方：
explicit关键字只对有一个参数的类构造函数有效, 
如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了
explicit A(int i， int j) {
  m_a = i;
}
有一个例外：
就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 
此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
explicit A(int i， int j = 0) {
  m_a = i;
}
A(10);             // 这是可以的
A  s = 10;         // 不可以的，因为explicit关键字取消了隐式转换 
A s;               // 不可以的，因为没有默认的构造函数
A s("hello");      // 可以的
A s = "hello";     // 可以的
A s = 'c';         // 不可以的

````

总结：
explicit关键字只需用于类内的单参数构造函数前面。
由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。
google的c++规范中提到：
explicit的优点是可以避免不合时宜的类型变换，缺点无。
所以google约定所有单参数的构造函数都必须是显示的，
只有极少数情况下拷贝构造函数可以不声明称explicit，例如作为其他类的透明包装器的类。
effective c++中说：
被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。
因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。
除非我有一个好理由允许构造函数被用于隐式类型转换，
否则我会把它声明为explicit，鼓励大家遵循相同的政策