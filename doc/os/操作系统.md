## 上下文切换

[深入理解CPU上下文切换](https://zhuanlan.zhihu.com/p/99923968)

对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。

上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。

从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。

在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，

再读入下一个进程的状态，然后执行此进程。

## 为什么进程上下文切换比线程上下文切换代价高？

进程切换分两步：

* 切换页目录以使用新的地址空间
* 切换内核栈和硬件上下文

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

* 线程上下文切换和进程上下文切换最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。
这两种上下文切换的处理都是通过操作系统内核来完成的。
内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

* 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。
简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。
但是在线程的切换中，不会出现这个问题。


## 进程调度算法有哪些？

### 调度种类

* 高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；

* 低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；

* 中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。

### 非抢占式调度与抢占式调度

* 非抢占式：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。

* 抢占式：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。

### 调度策略的设计

* 响应时间: 从用户输入到产生反应的时间

* 周转时间: 从任务开始到任务结束的时间

CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，

用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。

### 进程调度的任务

保存处理机的现场信息
首先要保存当前进程的处理机的现场信息，如程序计数器、多个通用寄存器中的内容等。
按某种算法选取进程
按照某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分给他。
把处理器分配给进程
由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关的处理现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交给该进程，让它从上次的断点处恢复运行。

### 进程的调度算法

* 先来先服务调度算法 FIFO或First Come, First Served (FCFS)
调度的顺序就是任务到达就绪队列的顺序。
公平、简单(FIFO队列)、非抢占、不适合交互式。
未考虑任务特性，平均等待时间可以缩短。

* 最短作业优先调度算法 Shortest Job First (SJF)
最短的作业(CPU区间长度最小)最先调度。
可以保证最小的平均等待时间。

* Shortest Remaining Job First (SRJF)

SJF的可抢占版本，比SJF更有优势。

SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。

* 优先权调度算法
每个任务关联一个优先权，调度优先权最高的任务。
注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。

* 时间片轮转调度算法
设置一个时间片，按时间片来轮转调度（“轮叫”算法）
优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；
时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。

* 多队列调度算法
按照一定的规则建立多个进程队列
不同的队列有固定的优先级（高优先级有抢占权）
不同的队列可以给不同的时间片和采用不同的调度方法
存在问题1：没法区分I/O bound和CPU bound；
存在问题2：也存在一定程度的“饥饿”现象；

* 多级反馈队列调度
在级队列的基础上，长期得不到运行的队列优先级会被提高。
可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。
最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。


## 系统调用与库函数的区别

* 系统调用(System call)是程序向系统内核请求服务的方式。可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。

* 库函数：把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间。

* 在移植性方面，不同操作系统的系统调用一般是不同的，移植性差；而在所有的ANSI C编译器版本中，C库函数是相同的。

* 在调用开销方面，系统调用需要在用户空间和内核环境间切换，开销较大；而库函数调用属于“过程调用”，开销较小。



## 中断与系统调用
所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，

转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。

中断的分类三类：
* 内部异常中断：由计算机硬件异常或故障引起的中断；
* 软中断：由程序中执行了引起中断的指令而造成的中断（这也是和我们将要说明的系统调用相关的中断）；
* 外部中断：由外部设备请求引起的中断，称为外部中断；

简单来说，对中断的理解就是对一些特殊事情的处理。与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。

另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。

典型的中断优先级如下所示:

机器错误 > 时钟 > 磁盘 > 网络设备 > 终端 > 软件中断

## 用户态和内核态

在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。

用户空间就是用户进程所在的内存区域，相对的，系统空间就是操作系统占据的内存区域。用户进程和系统进程的所有数据都在内存中。处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

用户态切换到内核态的方式如下：
* 系统调用：程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。如写数据write，创建进程fork，vfork等都是系统调用。

8 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

* 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

用户态和核心态(内核态）之间的区别是什么呢？