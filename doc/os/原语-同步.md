## 操作系统—同步原语

https://segmentfault.com/a/1190000016416989

CPU多核同步原语
https://zhuanlan.zhihu.com/p/48460953

下面这个代码段展示了一个生产者和一个消费者时的方案

```c++
volatile int empty_slot = 5;
volatile int filled_slot = 0;

void producer(void)
{
  int new_msg;
  while(true) {
    new_msg = produce_new();
    while(empty_slot == 0);//没有空位可使用
    empty_slot--;
    buffer_add(new_msg);
    filled_slot ++;
  }
}

void consumer(void)
{
  int cur_msg;
  while(true){
    while (filled_slot == 0);//没有对象可消耗
    filled_slot --;
    cur_msg = buffer_remove();
    empty_slot ++;
    consume_msg(cur_msg);
  }
}

```

生产者消费者模型在并行编程中很常见，为了正确、高效地解决这些同步问题，前人抽象出了一系列同步原语供开发者使用。

### 1. 竞态条件

在一般的操作系统中，不同的进程可能会分享一块公共的存储区域，例如内存或者是硬盘上的文件，这些进程都允许在这些区域上进行读写。
操作系统有一些职责，来协调这些使用公共区域的进程之间以正确的方式进行想要的操作。这些进程之间需要通信，需要互相沟通，有商有量，才能保证一个进程的动作不会影响到另外一个进程正常的动作，进而导致进程运行后得不到期望的结果。在操作系统概念中，通常用 IPC（Inter Process Communication，即进程间通信）这个名词来代表多个进程之间的通信。

为了解释什么是竞态条件（race condition），我们引入一个简单的例子来说明：
一个文件中保存了一个数字 n，进程 A 和进程 B 都想要去读取这个文件的数字，并把这个数字加 1 后，保存回文件。假设 n 的初始值是 0，在我们理想的情况下，进程 A 和进程 B 运行后，文件中 n 的值应该为 2，但实际上可能会发生 n 的值为 1。我们可以考量一下，每个进程做这件事时，需要经过什么步骤：

```
读取文件里 n 的值
令 n = n + 1
把新的 n 值保存回文件。
```

在进一步解释竞态条件之前，必须先回顾操作系统概念中的几个知识点：

* 进程是可以并发运行的，即使只有一个 CPU 的时候）
* 操作系统的时钟中断会引起进程运行的重新调度
* 除了时钟中断，来自其它设备的中断也会引起进程运行的重新调度

假设进程 A 在运行完步骤 1 和 2，但还没开始运行步骤 3 时，发生了一个时钟中断，这个时候操作系统通过调度，让进程 B 开始运行，进程 B 运行步骤 1 时，发现 n 的值为 0，于是它运行步骤 2 和 3，最终会把 n = 1 保存到文件中。之后进程 A 继续运行时，由于它并不知道在它运行步骤 3 之前，进程 B 已经修改了文件里的值，所以进程 A 也会把 n = 1 写回到文件中。这就是问题所在，进程 A 在运行的过程中，会有别的进程去操作它所操作的数据。

唯一能让 n = 2 的方法，只能期望进程 A 和进程 B 按顺序分别完整地运行完所有步骤。
我们可以给竞态条件下一个定义了

两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的准确时序，称为竞态条件。

在上述的文字中，我们使用进程作为对象来讨论竞态条件，实际上对于线程也同样适用，

这里的线程包含但不限于内核线程、用户线程。因为在操作系统中，进程其实是依靠线程来运行程序的

### 2. 互斥锁

如何避免 race condition，我们需要以某种手段，确保当一个进程在使用一个共享变量或者文件时，其它的进程不能做同样的操作，换言之，我们需要“互斥”。

以上述例子作为例子，我们可以把步骤 1 - 3 这段程序片段定义为临界区，临界区意味着这个区域是敏感的，因为一旦进程运行到这个区域，那么意味着会对公共数据区域或者文件进行操作，也意味着有可能有其它进程也正运行到了临界区。如果能够采用适当的方式，使得这两个进程不会同时处于临界区，那么就能避免竞态条件。
也就是，我们需要想想怎么样做到“互斥”

#### 2.1 临界区问题

互斥的本质就是阻止多个进程同时进入临界区


* 硬件实现：关闭中断

  我们可以通过关闭中断来解决单核的临界区问题，关中断意味着当前执行的线程不会被其他线程抢占，

  因此线程在进入临界区之前关闭中断，在离开临界区后开启中断，从而保证任意时刻只有一个线程执行临界区。

  关中断在执行在单核中满足了，互斥访问，有限等待，空闲让进。

  但是在多核中，关闭中断无法阻止多个同时运行的线程需要执行临界区。

  之前提到的例子中，进程 B 之所以能够进入临界区，是因为进程 A 在临界区中受到了中断。如果我们让进程 A 在进入临界区后，立即对所有中断进行屏蔽，离开临界区后，才响应中断，那么即使发生中断，那么 CPU 也不会切换到其它进程，因此此时进程 A 可以放心地修改文件内容，不用担心其它的进程会干扰它的工作。
  然而，这个设想是美好，实际上它并不可行。第一个，如果有多个CPU，那么进程 A 无法对其它 CPU 屏蔽中断，它只能屏蔽正在调度它的 CPU，因此由其它 CPU 调度的进程，依然可以进入临界区；第二，关于权力的问题，是否可以把屏蔽中断的权力交给用户进程？如果这个进程屏蔽中断后再也不响应中断了， 那么一个进程有可能挂住整个操作系统。

* 软件实现：皮特森算法(Peterson 算法)

  皮特森算法分可以用于多核的临界区问题

* 软硬件协同：使用原子操作实现互斥锁

  我们还可以利用硬件提供的原子操作，设计新的软件算法来解决临界区问题。

  原子操作：不可被打断的一个或一系列操作，即要么这一系列指令都执行完成，要么这一系列指令一条都没有执行，不会出现执行到一半的状态。


### 3. 自旋锁

### 4. 条件变量

### 5. 信号量

  上述解决生产者和消费者问题的两个计时器，就是信号量，除了初始化之外，信号量只能通过两个操作来更新，P操作即检索，V操作即自增，因此信号量又称为PV原语，为了便于理解，一般会使用wait和signal来表示信号量的P和V操作。

  wait操作用于用于等待，当信号量的值小于或等于0时进入循环等待。
  signal操作则用于通知，其会增加信号量的值供wait的线程使用。


### 死锁

必要条件：

* 互斥访问
* 请求保持
* 不可剥夺
* 循环等待

如何处理死锁问题：

* 预防死锁：通过设置某些限制条件，破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量
* 避免死锁：不是事先采取各种限制措施，在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)
* 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大。
* 解除死锁：与检测死锁配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。
* 忽略死锁：windows，Linux个人版都不做死锁处理，直接忽略，大不了重启就好了，小概率事件，代价可以接受。
例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
### 优先级反转

优先级反转的意思就是:

当一个低优先级线程获取了一个锁并进入临界区执行，那么当一个高优先级线程也要获取该锁并执行时，

需要等待低优先级执行完并放锁后才能执行，因此出现了低优先级先于高优先级执行的情况，这既是优先级反转。