## 操作系统—同步原语

下面这个代码段展示了一个生产者和一个消费者时的方案

```c++
volatile int empty_slot = 5;
volatile int filled_slot = 0;

void producer(void)
{
  int new_msg;
  while(true) {
    new_msg = produce_new();
    while(empty_slot == 0);//没有空位可使用
    empty_slot--;
    buffer_add(new_msg);
    filled_slot ++;
  }
}

void consumer(void)
{
  int cur_msg;
  while(true){
    while (filled_slot == 0);//没有对象可消耗
    filled_slot --;
    cur_msg = buffer_remove();
    empty_slot ++;
    consume_msg(cur_msg);
  }
}

```

生产者消费者模型在并行编程中很常见，为了正确、高效地解决这些同步问题，前人抽象出了一系列同步原语供开发者使用。


### 1. 互斥锁

#### 1.1 临界区问题

* 硬件实现：关闭中断

  我们可以通过关闭中断来解决单核的临界区问题，关中断意味着当前执行的线程不会被其他线程抢占，

  因此线程在进入临界区之前关闭中断，在离开临界区后开启中断，从而保证任意时刻只有一个线程执行临界区。

  关中断在执行在单核中满足了，互斥访问，有限等待，空闲让进。

  但是在多核中，关闭中断无法阻止多个同时运行的线程需要执行临界区。

* 软件实现：皮特森算法

  皮特森算法分可以用于多核的临界区问题

* 软硬件协同：使用原子操作实现互斥锁

  我们还可以利用硬件提供的原子操作，设计新的软件算法来解决临界区问题。

  原子操作：不可被打断的一个或一系列操作，即要么这一系列指令都执行完成，要么这一系列指令一条都没有执行，不会出现执行到一半的状态。


### 2. 自旋锁

### 3. 条件变量

### 4. 信号量

  上述解决生产者和消费者问题的两个计时器，就是信号量，除了初始化之外，信号量只能通过两个操作来更新，P操作即检索，V操作即自增，因此信号量又称为PV原语，为了便于理解，一般会使用wait和signal来表示信号量的P和V操作。

  wait操作用于用于等待，当信号量的值小于或等于0时进入循环等待。
  signal操作则用于通知，其会增加信号量的值供wait的线程使用。


### 死锁

必要条件：

* 互斥访问
* 请求保持
* 不可剥夺
* 循环等待

死锁预防：

* 避免互斥访问
* 避免请求保持
* 避免不可剥夺
* 避免循环等待

死锁避免：

系统存在两种状态，安全状态和非安全状态，

在安全状态下，一定存在一个安全序列，如果系统按照这个序列调度线程执行，即可避免资源不足的情况发生。

活锁：两个线程，1号线程获取锁a，2号线程获取锁b，然后1号获取锁b，2号获取锁a，发现锁被占有，然后1号放弃锁a，

2号放弃锁b，但是两个线程执行速度相似，1号又获取了锁a，2号又获取了锁b，导致循环往复，这是活锁现象

### 优先级反转

优先级反转的意思就是:

当一个低优先级线程获取了一个锁并进入临界区执行，那么当一个高优先级线程也要获取该锁并执行时，

需要等待低优先级执行完并放锁后才能执行，因此出现了低优先级先于高优先级执行的情况，这既是优先级反转。